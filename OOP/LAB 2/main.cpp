// Темы:
// Простое наследование. Виртуальные функции. Абстрактные классы.
// Битовые поля.


#include <tchar.h>
#include <Windows.h>
#include "Rect.h"
#include "Circle.h"
#include "MyByte.h"
#define	  stop __asm nop
#define curex 3
int _tmain(int argc, _TCHAR* argv[])
{
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);
#if curex == 1
	//Задание 1.Простое наследование.Аргументы конструктора,
	// передаваемые в базовый класс.

	//Создайте иерархию классов:
	//базовый класс Shape (который описывает любую фигуру)
	//и два производных класса Rect и Circle.
	//Подумайте: какие данные и методы нужно ввести в базовый
	//и производные классы (например, любую фигуру можно сделать
	//цветной => в базовом классе можно ввести переменную, которая
	//будет определять цвет фигуры.
	//Подсказка: для хранения цвета объявите перечисление (RED,GREEN,BLUE...);
	
	Rect redsquare(0, 5, 0, 5, Rect::RED);
	std::cout << redsquare << "1111\n";
	Circle bluecircle(5, 5, 2, Circle::BLUE);
	std::cout << bluecircle;
	//В конструкторах производных классов предусмотрите передачу
	//параметра-цвета конструктору базового класса.
	//При создании и уничтожении объекта производного типа определите
	//последовательность вызовов конструкторов и деструкторов базового
	//и производного классов
	stop
#endif


	
//////////////////////////////////////////////////////////////////////

#if curex == 2
	//Задание 2.Виртуальные функции.
	//2а) Модифицируйте классы Shape,Rect и Circle:
	//добавьте в каждый класс public метод void WhereAmI().
	//Реализация каждой функции должна выводить сообщение 
	//следующего вида "Now I am in class Shape(Rect или Circle)".
	//Выполните приведенный фрагмент, объясните результат.

		// в случае не виртуального метода, так как указатели базового типа, будет вызван метод базового класса Shape
		// раннее связывание
		// в случае виртуального метода реализуется механизм позднего связывания и будут вызываться методы производного класса
		// посредством указателя базового типа

	//2б) Сделайте метод WhereAmI() виртуальным.
	//Снова выполните приведенный фрагмент, объясните разницу.

	{
		Shape s(Shape::RED);
		Rect r(0,5,0,5, Rect::BLUE);
		Circle c(5,5,2, Circle::BLUE);

	
		//Метод какого класса вызывается в следующих строчках???
		s.WhereAmI();	//	???
		r.WhereAmI();	//	???
		c.WhereAmI();	//	???
		stop


		Shape* pShape = &s;
		Shape* pRect = &r;
		Shape* pCircle = &c;
    	pShape->WhereAmI();	//	???
		pRect->WhereAmI();	//	???
		pCircle->WhereAmI(); //	???
		stop


		//Заполните ... согласно комментариям
		Shape& rShape = s; //псевдоним s
		Shape& rRect = r; //псевдоним r
		Shape& rCircle = c; //псевдоним c
    	rShape.WhereAmI();	//вызов посредством rShape	???
		rRect.WhereAmI();	//вызов посредством	rRect	???
		rCircle.WhereAmI(); //вызов посредством rCircle	???
		stop
	}
#endif

//////////////////////////////////////////////////////////////////////
#if curex == 3
	//Задание 3.Виртуальные деструкторы.
	//Модифицируйте классы:
	//a) введите соответствующие
	// деструкторы (без ключевого слова virtual).
	//Реализация каждого деструктора
	//должна выводить сообщение следующего вида
	// "Now I am in Shape's destructor!" или
	// "Now I am in Rect's destructor!"
	//Выполните фрагмент. Объясните результат.

	// b) Добавьте в объявление деструкторов ключевое слово virtual 
	//Выполните фрагмент.Объясните разницу.

	
			//аналогично предыдущему

	//Подумайте: какие конструкторы вызываются в следующей строке?
		//Если в разработанных классов каких-то конструкторов
		//не хватает - реализуйте
		//Если Вы считаете, что в приведенном фрагменте чего-то
		//не хватает - добавьте

		Rect r(0,2,0,2, Rect::RED);
		Circle c(2, 2, 4, Circle::BLUE);
		Shape* ar[] = { new Rect(r), new Circle(r), new Circle() };
		//Вызовите для каждого элемента массива метод WhereAmI()

		delete ar[0];
		delete ar[1];
		delete ar[2];

	stop
#endif

#if curex == 4
	//Задание 4*. В чем заключается отличие 1) и 2)
	{
		Shape* pShapes = new Rect[10];//1)создали массив из объектов Rect и установили указатель на Shape на начало первого элемента массива
		Rect* pRects = new Rect[10];//2)создали массив из объектов Rect и установили указатель на Rect на начало первого элемента массива

		//Попробуйте вызвать метод WhereAmI() для каждого элемента обоих массивов -
		//в чем заключается проблема??? 
		static_cast<Rect *>(pShapes)[1].WhereAmI(); //проблема в том, что классы Shape и Rect занимают разное количество памяти
							   //и при перестановке указатель Shape * начинает указывать в неопределенное место памяти. 
		pRects[1].WhereAmI();

		//Освободите динамически захваченную память
		delete[] pShapes;
		delete[] pRects;
	}

#endif

//////////////////////////////////////////////////////////////////////
#if curex == 5
	//Задание 5.Виртуальные функции и оператор разрешения области видимости. 

	{
		Rect r(0,2,0,2, Rect::RED);
		Shape* p = &r;	
		p->WhereAmI();//вызывает метод из класса Rect
		stop


			//4a Оператор разрешения области видимости.
			//Посредством объекта r и указателя p вызовите виртуальную функцию
			//WhereAmI()класса Shape
			p->Shape::WhereAmI();
		
	}
#endif
//////////////////////////////////////////////////////////////////////
#if curex == 6
	//Задание 6.Чисто виртуальные функции. 
	//Введите в базовый класс метод void Inflate(int); Подумайте:
	//можно ли реализовать такой метод для базового класса? => как его нужно объявить.
	//Реализуйте этот метод для производных классов.
	{
		Rect r(0,2,0,2,Rect::RED);
		Shape* p = &r;
		std::cout << *static_cast<Rect *>(p);
		p->Inflate(5);
		std::cout << *static_cast<Rect *>(p);
		Circle c(0,0, 5, Circle::RED);
		p = &c;
		std::cout << *static_cast<Circle *>(p);
		p->Inflate(5);
		std::cout << *static_cast<Circle *>(p);
	}
#endif

//////////////////////////////////////////////////////////////////////
#if curex == 7
	//Задание 7.Объединения (union) C++. Битовые поля.
	//1.
	//Создайте следующие классы для различных представлений значений байта:
	//Bin - для двоичного представления
	//Hex - для шестнадцатерчного представления
	//Oct - для восьмеричного представления.
	//Подсказка 1: - для удобства используйте битовые поля.
	//Подсказка 2: - конструкторов в таких вспомогательных классах быть не должно,
	//так как все они будут членами объединения (union).
	//2.
	//В каждом классе введите метод Show, который должен выводить значение в
	//соответствующем виде
	//3.
	//Посредством объединения MyByte предоставьте пользователю возможность манипулировать
	//одним и тем же значением по-разному:
	//а) выводить: десятичное, шестнадцатеричное, восьмеричное, двоичное значение байта 
	//          а также символ, соответствующий хранимому значению (если есть соответствие);
	//б) выводить отдельные (указанные посредством параметра) шестнадцатеричные,
	//			восьмеричные, двоичные цифры;
	//в) изменять отдельные двоичные, восьмеричные или шестнадцатеричные цифры;

	MyByte byte;
	int pos = 1;
	void (MyByte::*fptr[3])() const {&MyByte::ShowInteract, &MyByte::ShowPosInteract, 
		reinterpret_cast<void (MyByte::*)() const>(&MyByte::EditPosInteract)};
	std::cout << "Выберите действия: 1) Вывести на экран, 2) Вывести разряд на экран, 3) Редактировать разряд:\n";
	int choice = 0;
	while (std::cin >> choice)
	{
		while ( choice < 1 || choice > 3)
		{
			std::cout << "Недопустимый выбор, повторите: ";
			std::cin.clear();
			std::cin >> choice;
		}
		(byte.*fptr[choice - 1])();
		std::cout << "Выберите действия: 1) Вывести на экран, 2) Вывести разряд на экран, 3) Редактировать разряд:\n";
		std::cout << "ctrl-Z для выхода.\n";
	}
#endif

	{
		MyByte b(255);
		b.ShowHex();
	}
	
	return 0;
}//endmain

