#include "myRect.h"
#include "myString.h"
#include "general.h"
#include "Barrel.h"
#include <iostream>
#include <Windows.h>
#include <string>
#define stop __asm nop
#define curex 6

extern int ConsDestRatio;

int main()
{
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);
	using namespace std;

#if curex == 1




	//Задание 1.Объявление класса. Создание экземпляра класса.
	//Вызов методов класса. 
	//Откройте закладку Class View - (здесь Вы увидите имена методов и
	//данных - классов Rect и MyString)
	//Обратите внимание на пиктограммы слева от имен членов класса - они
	//обозначают спецификатор доступа к каждому члену класса.

	//Какой конструктор вызывается при создании экземпляра класса?
	{
		Rect rect1; // Если конструктор не определен, то вызывается автоматический конструктор класса по умолчанию.
		//Если конструктор(ы) определен(ы), то вызывается подходящий конструктор класса
		std::cout << "Rect1: \n" << rect1;
		stop
	}

	//1a. Объявите и определите конструктор с параметрами для
	//инициализации переменных класса. Создайте экземляры класса Rect
	//с помощью конструктора с параметрами. Если компилятор выдает
	//ошибку в предыдущем фрагменте, подумайте - чего ему не
	//хватает? Добейтесь отсутствия ошибок.
	//Выполняя задание с самого начала по шагам, определите:
	//в какой момент происходит вызов конструктора(какого?)?

	Rect rect2{ 2,4,5,6 }; // вызов конструктора происходит во время инициализации экземпляра класса
	std::cout << "Rect2: \n" << rect2;

	stop
		//1б. При конструировании объекта посредством конструктора без параметров
		//предусмотрите инициализацию переменных класса, например, нулем

		Rect rect3;
	std::cout << "Rect3: \n" << rect3;

	//1в. Подумайте, как следует поступать в случае, когда пользователь задал
	//координаты следующим образом:

	Rect rrr(4, 3, 2, 1); //??? Определить конструктор с параметрами.
	std::cout << "rrr:\n" << rrr;

	stop
		//1г. Объявите, определите и вызовите метод класса InflateRect(), 
		//который увеличивает размеры прямоугольника на заданные приращения
		//(раздвигая стороны от центра - каждую сторону на свое значение).
		//Подсказка: объявить и определить методы можно не только "вручную",
		//но и с помощью Wizard-a Class View. Для этого: откройте закладку
		//ClassView окна проекта, сделайте активным класс Rect и нажмите
		//правую кнопку мыши - в появившемся контекстном меню выберите
		//Add/Add Member Function... С помощью появившейся диалоговой панели
		//"дайте указания" Wizard-у как объявить и определить метод.

		std::cout << "Inflate part:\n";
	Rect rectangle{ 2,4,2,4 };
	std::cout << "Inflate rectangle left and right side by 2: \n";
	rectangle.InflateRect(2, 2, 0, 0);
	std::cout << "rectangle2: " << rectangle2;
	stop

#endif

#if curex == 2
		//Задание 2.Перегрузка конструкторов и методов класса.
		//Конструктор копирования.

		//2а.Объявите и определите конструктор копирования в классе Rect.
		//Выполняя задание по шагам, определите, какой
		//конструктор вызывается при создании r1,r2,r3 и r4?
		//Чему равны переменные созданных объектов?
		Rect r1;
	Rect r2(1, 2, 3, 4);
	Rect r3 = r1;
	Rect r4(r2);
	stop


		//2б. Объявите и определите в классе Rect метод InflateRect(),
		  //который принимает два аргумента, по умолчанию равных 1, и 
		  //раздвигает стороны прямоугольника на на заданные приращения.
		  //Для каких объектов вызывается функция InflateRect()?
		r1.InflateRect(1, 1);
	r2.InflateRect(2, 2);
	//Какая из функций InflateRect() вызывается в каждом из трех случаев?
	r3.InflateRect(2, 2, 2, 2);
	r3.InflateRect(3, 3);
	r3.InflateRect(5);
	r3.InflateRect();
	stop
#endif

#if curex == 3
		//Задание 3.Спецификаторы доступа. Инкапсуляция. 
	{
	Rect r;
	//Раскомментируйте следующую строку. Объясните ошибку
	//компилятора

//	int tmp = r.m_left; // член класса m_left находится в защищенном разделе private



	//Введите в класс Rect метод void SetAll(...),
	//который присваивают переменным класса передаваемые
	//значения. Вызовите созданный метод, проверьте корректность. 

	Rect rect{ 2,4,4,2 };
	std::cout << "rect: " << rect;
	std::cout << "SetAll(4,8,8,4)\n";
	rect.SetAll(4, 8, 8, 4);
	std::cout << "rect: " << rect;
	//Введите в класс Rect парный метод GetAll(...),
	//который "достает" значения private-переменных класса.
	//Вызовите созданный метод, проверьте корректность. 
	//Печатать ? Сохранить в переменную?
	Point4 points;
	rect.GetAll(points);
	std::cout << "Left = " << points.x1 << std::endl;
	std::cout << "Right = " << points.x2 << std::endl;
	std::cout << "Top = " << points.y1 << std::endl;
	std::cout << "Bottom = " << points.y2 << std::endl;

	int x1, y1, x2, y2;
	rect.GetAll(x1, y1, x2, y2);
	stop
	}
#endif

#if curex == 4
		//Задание 4.Передача экземпляра класса в качестве параметра
		//функции. Возвращение объекта класса по значению. Поставив
		//остановы в конструкторе копирования или выполняя фрагмент
		//по шагам, определите: в какой момент происходит обращение
		//к конструктору копирования. 
		//Создайте глобальную функцию 
		// Rect BoundingRect(Rect, Rect);
		//которая принимает два объекта класса Rect по значению и
		//возвращает объект класса Rect, который является прямоугольником,
		//в который вписаны заданные прямоугольники. Как происходит
		//передача параметров и возвращение объекта класса?

		//Замечание*: хорошо было бы учесть тот факт, что прямоугольник
		//может оказаться "ненормализованным", то есть m_left>m_right или/и
		//m_top>m_bottom

	{

		Rect r1(-5, 2, 3, 4), r2(0, 3, 2, 5), r3; // Конструктор определен так, что при передаче не корректных параметров
		//проведется автоматическая нормализация
		r3 = BoundingRect(r2, r1);
		std::cout << r3;
		stop

			//Задание 4а. Передача объектов по ссылке.
			//Создайте глобальную функцию BoundingRect2, которая выполняет ту же
			//задачу, принимая параметры по ссылке
			//Вызываются ли конструкторы при передаче параметров?

			r1 = Rect(0, 10, 0, 10);
		r2 = Rect(-1, 4, 3, 5);
		r3.BoundingRect(r1, r2);
		std::cout << r3;
		stop
	}

#endif
#if curex == 5

	//Задание 5. Указатель на класс. Объявите и определите
	//явный деструктор класса. Поставьте остановы в 
	//конструкторе (конструкторах) и деструкторе. Определите: когда для
	//каждого из объектов вызывается конструктор, а когда - деструктор?
	{
		Rect r1; // сработал конструктор r1
		Rect* pR = new Rect(1, 2, 1, 2);	//Сработал конструктор pR
		{
			Rect r2(r1); // сработал конструктор копирования r2
			Rect arRect[2]; // Сработал конструктор arRect[0], arRect[1]
			for (int i = 0; i < 3; i++)
			{
				static Rect r3(i, i, i, i); // сработал конструктор r3 1 раз
				Rect r4(*pR); //Сработал Конструктор копирования r4
				Rect r5(i, i, i, i);//Сработал конструктор r5
			}//сработал деструктор r4, r5
		}//сработал деструктор arRect[0], arRect[1], r2
		delete pR;	 //сработал деструктор pR
		stop
	}//сработал деструктор r1
	std::cout << ConsDestRatio;
#endif

#if curex == 6
	//Задание 6.Конструктор + деструктор = функциональное
	// замыкание. Класс MyString
	// Посредством конструктора (конструкторов) и деструктора обеспечьте
	//корректные инициализацию и деактивацию объекта
	//C помощью остановов определите когда происходит
	//захват и освобождение памяти для строки-члена класса
	{
		MyString	str1("It's my string!");
		MyString	str2 = str1;
		//Создайте метод GetString(), который обеспечит доступ к хранящейся строке.
		//С помощью cout и метода GetString() распечатайте строку объекта str
		//Замечание: подумайте, как следует корректно реализовать метод GetString().
		std::cout << str1 << str2;
		std::cout << "GetString(): " << str1.GetString() << std::endl;
		//...
	}
	stop


		//6a. Раскомментируйте следующий фрагмент. Подумайте - какие
		//неприятности Вас ожидают. Попробуйте исправить положение (как?)
	{
		MyString str1("The first string!"); //нужен конструктор копирования.
		MyString str2 = str1;
	}
		stop

		//6б. Реализуйте метод SetNewString, который будет заменять строку
		// на новую
	{
		MyString str("This is string!");
		std::cout << str;
		str.SetNewString("This is another string!");
		std::cout << str;

	}

		//6г. Создайте глобальную функцию, которая будет принимать любое
		//количество указателей на строки, а возвращать объект MyString,
		//в котором строка будет конкатенацией параметров
	{
		MyString str1("Test1");
		MyString str2("Test2");
		MyString str4;
		MyString str5 = MyStrCat(2, str1.GetString(), str2.GetString());
		MyString str3 = str4;
		str3.MyStrCat(4, str1.GetString(), str2.GetString(), str4.GetString(), str5.GetString());
		std::cout << str4.GetString();
		std::cout << str3;
	}
#endif
#if curex == 7

	//Задание 7.Массив объектов класса.
	{
		//Объявите и проинициализируйте массив ar из объектов
		// типа MyString. Например:
		//Как задать размерность? 

		/*const int N = 3;
		MyString arstr[N] = { "test1", "test2", "test3" };
		for (size_t i = 0; i < N; i++)
			std::cout << arstr[i] << std::endl;*/

			//Проверка - печать строк-членов класса


			//Увеличьте размер массива, не изменяя список инициализаторов:
			//N=5???

		const int N = 5;
		MyString arstr[N] = { "test1", "test2", "test3" };
		for (size_t i = 0; i < N; i++)
			std::cout << arstr[i] << std::endl;


		//Объявите и проинициализируйте массив объектов	типа Rect.

		Rect Field[5]{ {1,2,1,2}, {1,3,1,3}, {2,5,2,5}, {5,7,2,6} };
		for (size_t i = 0; i < N; i++)
			std::cout << Field[i];
	}
	stop

#endif
#if curex == 8

		//Задание 8.Массив указателей на объекты класса.
	{
		//Объявите и проинициализируйте массив arPtr из трех 
		//указателей на объекты типа MyString.

		MyString str1("Test1");
		MyString str2("Test2");
		MyString str3("Test3");
		MyString * arPtr[3] {&str1, &str2, &str3};
		//Печать строк-членов класса
		for (size_t i = 0; i < 3; i++)
			std::cout << *(arPtr[i]) << std::endl;

	}
		stop
#endif

#if curex == 9
		//Задание 9.  Решите с помощью классов следующую задачу:
		//даны две бочки известного объема. В одной бочке в начальный момент
		//времени содержится спирт (96%), в другой – вода.
		//Кружкой емкостью 1л переливаем итеративно содержимое из одной бочки
		//в другую следующим способом: на каждой итерации
		//зачерпнули из первой бочки -> вылили во вторую
		//зачерпнули из второй бочки -> вылили в первую.
		//Требуется определить номер итерации, на которой концентрация спирта в
		//первой бочке станет меньше 50%.

		//Barrel spirit(...);
		//Barrel water(...);
		//...
		//	while(концентрация спирта в бочке spirt > 50%)
		//	{
		//		spirt.Pereliv(water); //или spirt.Pereliv(water, объем_кружки);
		//		water.Pereliv(spirt); // аналогично
		//		...

	Barrel Water(100.0, 0.0);
	Barrel Spirit(100, 0.96);
	int count = 0;

	while (Spirit.getconcentration() > 0.5 && count < 1000)
	{
		count++;
		Spirit.pour(Water, 1);
		Water.pour(Spirit, 1);
	}
	std::cout << count << ": " << Water << Spirit;

#endif
	return 0;
}

